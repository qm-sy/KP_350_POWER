C51 COMPILER V9.60.7.0   COMMUNICATION                                                     02/05/2025 16:57:39 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE COMMUNICATION
OBJECT MODULE PLACED IN ..\Output\communication.obj
COMPILER INVOKED BY: D:\APP\Keil_v5\C51\BIN\C51.EXE ..\BSP\Src\communication.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\
                    -BSP\Inc;..\Core\Inc;..\Driver;..\Emembed\Inc;..\SYSTEM\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\communication.lst) OBJEC
                    -T(..\Output\communication.obj)

line level    source

   1          #include "communication.h"
   2          
   3          RS485 rs485;
   4          uint8_t TX4_busy_Flag = 1;
   5          
   6          /**
   7           * @brief       串口2中断处理函数
   8           *
   9           * @param   
  10           *
  11           * @return  void
  12          **/
  13          void Uart2_ISR() interrupt 8 
  14          {   
  15   1          /* 1, 检测到硬件将S2TI置1，即发送完毕                       */
  16   1          if( S2CON & S2TI )          //
  17   1          {
  18   2              /* 2, 软件将S2TI清零，等待发送标志位重置，可继续发送    */
  19   2              S2CON &= ~S2TI;         
  20   2              rs485.TX2_busy_Flag = 0;
  21   2              
  22   2              /* 3, 依次将TX2_buf中数据送出（写S2BUF操作即为发送）    */
  23   2              if( rs485.TX2_send_bytelength != 0 )
  24   2              {
  25   3                  S2BUF = rs485.TX2_buf[rs485.TX2_send_cnt++];
  26   3                  rs485.TX2_send_bytelength--;
  27   3              }else
  28   2              {
  29   3                  rs485.TX2_send_cnt = 0;
  30   3              }
  31   2          }
  32   1          
  33   1          /* 1, 检测到硬件将S2RI置1，即接收完毕                       */
  34   1          if( S2CON & S2RI )
  35   1          {
  36   2              /* 2, 软件将S2RI清零，等待接收标志位重置，可继续发送    */
  37   2              S2CON &= ~S2RI;
  38   2      
  39   2              /* 3, 判断数据包是否接收完毕                           */
  40   2              if( !rs485.RX2_rev_end_Flag )
  41   2              {
  42   3                  /* 4, 数据包大于RX_buf 则从头计数                  */
  43   3                  if( rs485.RX2_rev_cnt > 128 )
  44   3                  {
  45   4                      rs485.RX2_rev_cnt = 0;
  46   4                  }
  47   3      
  48   3                  /* 5, 依次将RX2_buf中数据接收（读S2BUF操作即为接收）*/
  49   3                  rs485.RX2_buf[rs485.RX2_rev_cnt] = S2BUF;
  50   3                  rs485.RX2_rev_cnt++;
  51   3              }
  52   2              /* 6, 重置接收完毕判断时间                              */
  53   2              rs485.RX2_rev_timeout = 50;
C51 COMPILER V9.60.7.0   COMMUNICATION                                                     02/05/2025 16:57:39 PAGE 2   

  54   2          }
  55   1      }
  56          
  57          /**
  58           * @brief       是否接收完毕判断函数
  59           *
  60           * @param   
  61           *
  62           * @return  void
  63          **/
  64          void Tim0_ISR( void ) interrupt 1   //1ms
  65          {
  66   1          /* 1, 如果接收未超时                                             */
  67   1          if ( rs485.RX2_rev_timeout != 0 )  
  68   1          {
  69   2              rs485.RX2_rev_timeout--;
  70   2              /* 2, 如果接收超时                                          */
  71   2              if( rs485.RX2_rev_timeout == 0 )  
  72   2              {
  73   3                  if( rs485.RX2_rev_cnt > 0 )  
  74   3                  {   
  75   4                       /* 3, 接收完毕标志位亮起并初始化接收缓冲区         */
  76   4                      rs485.RX2_rev_end_Flag = 1;    
  77   4                  }
  78   3              }
  79   2          } 
  80   1      }
  81          
  82          /**
  83           * @brief       串口2发送1字节数据
  84           *
  85           * @param   
  86           *
  87           * @return  void
  88          **/
  89          void Uart2_Sendbyte( uint8_t dat )
  90          {
  91   1          while( rs485.TX2_busy_Flag );
  92   1          rs485.TX2_busy_Flag = 1;
  93   1          S2BUF = dat;
  94   1      
  95   1      }
  96          
  97          /**
  98           * @brief       串口2发送字符串
  99           *
 100           * @param   
 101           *
 102           * @return  void
 103          **/
 104          void Uart2_SendStr( uint8_t *sendstr )
 105          {   
 106   1          while(*sendstr)
 107   1          {
 108   2              Uart2_Sendbyte(*sendstr++);
 109   2          }
 110   1      }
 111          
 112          /**
 113           * @brief       串口2调用结构体初始化
 114           *
 115           * @param   
C51 COMPILER V9.60.7.0   COMMUNICATION                                                     02/05/2025 16:57:39 PAGE 3   

 116           *
 117           * @return  void
 118          **/
 119          void Uart2_Send_Statu_Init( void )
 120          {
 121   1          rs485.TX2_busy_Flag = 0;
 122   1          rs485.RX2_rev_end_Flag = 0;
 123   1          rs485.TX2_buf[128] = 0;
 124   1          rs485.RX2_buf[128] = 0;
 125   1          rs485.TX2_send_bytelength = 0;
 126   1          rs485.TX2_send_cnt = 0;
 127   1          rs485.RX2_rev_timeout = 0;
 128   1          rs485.RX2_rev_cnt = 0;
 129   1      }
 130          
 131          /**
 132           * @brief       串口4中断处理函数
 133           *
 134           * @param   
 135           *
 136           * @return  void
 137          **/
 138          void Uart4_ISR() interrupt 18
 139          {
 140   1          if (S4CON & S4TI)                //在停止位开始发送时，该位置1
 141   1          {
 142   2              S4CON &= ~S4TI;                              //清除S4CON寄存器对应S4TI位（该位必须软件清零）
 143   2              TX4_busy_Flag = 0;
 144   2          }
 145   1      
 146   1          if (S4CON & S4RI)                //串行接收到停止位的中间时刻时，该位置1
 147   1          {
 148   2              S4CON &= ~S4RI;              //清除S4CON寄存器对应S4RI位（该位必须软件清零）
 149   2                     
 150   2          }
 151   1      }
 152          
 153          /**
 154           * @brief       串口4发送1字节数据
 155           *
 156           * @param   
 157           *
 158           * @return  void
 159          **/
 160          void Uart4_Sendbyte( uint8_t dat )
 161          {
 162   1          while( TX4_busy_Flag );
 163   1          TX4_busy_Flag = 1;
 164   1          S4BUF = dat;
 165   1      
 166   1      }
 167          
 168          /**
 169           * @brief       串口4发送字符串
 170           *
 171           * @param   
 172           *
 173           * @return  void
 174          **/
 175          void Uart4_SendStr( uint8_t *sendstr )
 176          {   
 177   1          while(*sendstr)
C51 COMPILER V9.60.7.0   COMMUNICATION                                                     02/05/2025 16:57:39 PAGE 4   

 178   1          {
 179   2              Uart4_Sendbyte(*sendstr++);
 180   2          }
 181   1      }
 182          
 183          /**
 184           * @brief       串口重定向
 185           *
 186           * @param   c:字符串
 187           *
 188           * @return  c
 189          **/
 190          char putchar(char c)  // 串口重定向需要添加头文件stdio.h
 191          {
 192   1          S4BUF = c;
 193   1          while(TX4_busy_Flag);
 194   1          TX4_busy_Flag = 1;
 195   1          return c;
 196   1      }
 197          
 198          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    387    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    265       6
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
