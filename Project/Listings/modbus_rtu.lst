C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        02/09/2025 16:48:56 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MODBUS_RTU
OBJECT MODULE PLACED IN ..\Output\modbus_rtu.obj
COMPILER INVOKED BY: D:\APP\Keil_v5\C51\BIN\C51.EXE ..\Emembed\Src\modbus_rtu.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..
                    -\BSP\Inc;..\Core\Inc;..\Driver;..\Emembed\Inc;..\SYSTEM\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\modbus_rtu.lst) OBJECT(
                    -..\Output\modbus_rtu.obj)

line level    source

   1          #include "modbus_rtu.h"
   2          
   3          MODBIS_INFO modbus;
   4          
   5          /**
   6           * @brief       modbus_rtu  无奇偶校验
   7           *
   8           * @param   void
   9           *
  10           * @return  void 
  11          **/
  12          void Modbus_Event( void )
  13          {
  14   1          uint16_t crc,rccrc;
  15   1      
  16   1          /*1.接收完毕                                           */
  17   1          if( rs485.RX2_rev_end_Flag == 1 )
  18   1          {
  19   2              /*2.清空接收完毕标志位                              */    
  20   2              rs485.RX2_rev_end_Flag = 0;
  21   2      
  22   2              /*3.CRC校验                                         */
  23   2              crc = MODBUS_CRC16(rs485.RX2_buf, rs485.RX2_rev_cnt-2);
  24   2              rccrc = (rs485.RX2_buf[rs485.RX2_rev_cnt-2]<<8) | (rs485.RX2_buf[rs485.RX2_rev_cnt-1]);
  25   2      
  26   2              /*4.清空接收计数                                    */
  27   2              rs485.RX2_rev_cnt = 0; 
  28   2      
  29   2              /*5.CRC校验通过，进行地址域校验                      */
  30   2              if( crc == rccrc )
  31   2              {
  32   3                  /*6.地址域校验通过，进入相应功能函数进行处理      */
  33   3                  if( rs485.RX2_buf[0] == MY_ADDR )
  34   3                  {
  35   4                      switch ( rs485.RX2_buf[1] )
  36   4                      {
  37   5                          case 0x03:
  38   5                              Modbus_Fun3();
  39   5                              break;
  40   5      
  41   5                          case 0x04:
  42   5                              Modbus_Fun4();
  43   5                              break;
  44   5      
  45   5                          case 0x06:
  46   5                              Modbus_Fun6();
  47   5                              break;  
  48   5      
  49   5                          case 0x10:  
  50   5                              Modbus_Fun16();
  51   5      
  52   5                          default:
  53   5                              break;
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        02/09/2025 16:48:56 PAGE 2   

  54   5                      }
  55   4                  }
  56   3              }
  57   2          }
  58   1      }
  59          
  60          /**
  61           * @brief       读输出寄存器  03
  62           *
  63           * @param   void
  64           *
  65           * @return  void 
  66          **/
  67          void Modbus_Fun3( void )
  68          {
  69   1          uint16_t i;
  70   1      
  71   1          modbus.send_value_addr  = 3;                 //DATA1 H 位置
  72   1          modbus.byte_cnt   = (rs485.RX2_buf[4]<<8 | rs485.RX2_buf[5]) *2;
  73   1          modbus.start_addr = rs485.RX2_buf[2]<<8 | rs485.RX2_buf[3];
  74   1      
  75   1          rs485.TX2_buf[0]  = MY_ADDR;                //Addr
  76   1          rs485.TX2_buf[1]  = 0x03;                   //Fun
  77   1          rs485.TX2_buf[2]  = modbus.byte_cnt;        //Byte Count
  78   1      
  79   1          for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++ )
  80   1          {
  81   2              /*    每次循环前初始化byte_info                       */
  82   2              modbus.byte_info_H = modbus.byte_info_L = 0X00;
  83   2              switch (i)
  84   2              {
  85   3                  /*  40001  两路PWM 开关状态及风速查询                 */
  86   3                  case 0:
  87   3                      modbus.byte_info_H  = 0X00;
  88   3                      modbus.byte_info_L |= (PWMB_CCR7 / 184)<<2;                  //PWM7风速
  89   3                      modbus.byte_info_L |= (PWMB_CCR8 / 184)<<5;                  //PWM8风速
  90   3                      if( PWMB_CCER2 & 0X01 )
  91   3                      {
  92   4                          modbus.byte_info_L |= 0x01;                              //PWM7开关状态
  93   4                      }
  94   3                      if( PWMB_CCER2 & 0X10 )
  95   3                      {
  96   4                          modbus.byte_info_L |= 0x02;                              //PWM8开关状态
  97   4                      }
  98   3                      break;
  99   3      
 100   3                  /*  40002  LED开关状态查询                          */
 101   3                  case 1:
 102   3                      modbus.byte_info_H = 0X00;
 103   3                      if( DC_24V & 1 )
 104   3                      {
 105   4                          modbus.byte_info_L |= 0x00;                              //LED开关状态
 106   4                      }
 107   3                      break;
 108   3      
 109   3                  /*  40003  220V CH4开关状态及功率查询               */
 110   3                  case 2:
 111   3                      modbus.byte_info_H = 0X00;
 112   3                      modbus.byte_info_L = ((ac_220.time_delay - 58000) / 75)<<1;  //220V 功率
 113   3                      if( INTCLKO & 0x10 )
 114   3                      {
 115   4                          modbus.byte_info_L |= 0x01;                             //220V运行状态
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        02/09/2025 16:48:56 PAGE 3   

 116   4                      }
 117   3                      break;
 118   3      
 119   3                  /*  40004 NTC1 NTC2 alarm value查询                       */
 120   3                  case 3:
 121   3                      modbus.byte_info_H = temp.temp_alarm_value2;           
 122   3                      modbus.byte_info_L = temp.temp_alarm_value1;           
 123   3                      break;
 124   3      
 125   3                  /*  40005 NTC3 alarm value查询                            */
 126   3                  case 4:
 127   3                      modbus.byte_info_H = 0X00;   
 128   3                      modbus.byte_info_L = temp.temp_alarm_value3;          
 129   3                      break;
 130   3      
 131   3                  default:
 132   3                      break;
 133   3              }
 134   2              rs485.TX2_buf[modbus.send_value_addr++] = modbus.byte_info_H;
 135   2              rs485.TX2_buf[modbus.send_value_addr++] = modbus.byte_info_L;
 136   2          }
 137   1          slave_to_master(3 + modbus.byte_cnt);
 138   1      }
 139          
 140          
 141          /**
 142           * @brief       读输入寄存器  04
 143           *
 144           * @param   void
 145           *
 146           * @return  void 
 147          **/
 148          void Modbus_Fun4( void )
 149          {
 150   1          uint16_t i;
 151   1      
 152   1          modbus.send_value_addr  = 3;                //DATA1 H 位置
 153   1          modbus.byte_cnt   = (rs485.RX2_buf[4]<<8 | rs485.RX2_buf[5]) *2;
 154   1          modbus.start_addr = rs485.RX2_buf[2]<<8 | rs485.RX2_buf[3];
 155   1      
 156   1          rs485.TX2_buf[0]  = MY_ADDR;                //Addr
 157   1          rs485.TX2_buf[1]  = 0x04;                   //Fun
 158   1          rs485.TX2_buf[2]  = modbus.byte_cnt;        //Byte Count
 159   1      
 160   1          for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++ )
 161   1          {
 162   2              /*    每次循环前初始化byte_info                       */
 163   2              modbus.byte_info_H = modbus.byte_info_L = 0X00;
 164   2              switch (i)
 165   2              {   
 166   3                  /*  30001 NTC1 NTC2温度查询                     */
 167   3                  case 0:
 168   3                      modbus.byte_info_L = get_temp(NTC_1);
 169   3                      modbus.byte_info_H = get_temp(NTC_2);     
 170   3                      break;
 171   3      
 172   3                  /*  30002 NTC3 NTC4温度查询                     */    
 173   3                  case 1:
 174   3                      modbus.byte_info_L = get_temp(NTC_3);
 175   3                      modbus.byte_info_H = get_temp(NTC_4);
 176   3                      break;
 177   3      
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        02/09/2025 16:48:56 PAGE 4   

 178   3                  /*    30003 2路IR查询                         */
 179   3                  case 2:    
 180   3                      modbus.byte_info_H = 0xaa;
 181   3                      modbus.byte_info_L = 0xbb;
 182   3                      break;
 183   3      
 184   3                  /*    30004 I_OUT1 I_OUT2 电流查询              */
 185   3                  case 3:    
 186   3                      modbus.byte_info_H = get_current(I_OUT2);     
 187   3                      modbus.byte_info_L = get_current(I_OUT1);     
 188   3                      break;
 189   3      
 190   3                  /*    30005 I_OUT3 电流查询                     */
 191   3                  case 4:    
 192   3                      modbus.byte_info_H = 0X00;                    
 193   3                      modbus.byte_info_L = get_current(I_OUT3);     
 194   3                      break;
 195   3      
 196   3                  default:
 197   3                      break;
 198   3              }
 199   2              rs485.TX2_buf[modbus.send_value_addr++] = modbus.byte_info_H;
 200   2              rs485.TX2_buf[modbus.send_value_addr++] = modbus.byte_info_L;
 201   2          }
 202   1          slave_to_master(3 + modbus.byte_cnt);
 203   1      }
 204          
 205          /**
 206           * @brief       写单个输出寄存器  06
 207           *
 208           * @param   void
 209           *
 210           * @return  void 
 211          **/
 212          void Modbus_Fun6( void )
 213          {
 214   1          switch (rs485.RX2_buf[3])
 215   1          {
 216   2              /*  40001  两路PWM 开关状态及风速设置                 */
 217   2              case 0:             
 218   2                  memcpy(rs485.TX2_buf,rs485.RX2_buf,8);                            
 219   2      
 220   2                  if( rs485.TX2_buf[5] & 0X01 )
 221   2                  {
 222   3                      PWMB_CCER2 |= 0X01;
 223   3                  }else
 224   2                  {
 225   3                      PWMB_CCER2 &= 0XFE;
 226   3                  }
 227   2                  if( rs485.TX2_buf[5] & 0X02 )
 228   2                  {
 229   3                      PWMB_CCER2 |= 0X10;
 230   3                  }else
 231   2                  {
 232   3                      PWMB_CCER2 &= 0XEF;
 233   3                  }
 234   2                  
 235   2                  PWMB_CCR7 = ((rs485.TX2_buf[5]>>2) & 0x07)*184;
 236   2                  PWMB_CCR8 = (rs485.TX2_buf[5]>>5)*184;
 237   2      
 238   2                  rs485.TX2_send_bytelength = 8;
 239   2      
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        02/09/2025 16:48:56 PAGE 5   

 240   2                  DR2 = 1;                                    //485可以发送
 241   2                  delay_ms(5);
 242   2                  S2CON |= S2TI;                              //开始发送
 243   2      
 244   2                  eeprom.pwm_info = rs485.TX2_buf[5];
 245   2                  eeprom_data_record();
 246   2      
 247   2                break;
 248   2      
 249   2              /*  40002  24V LED开关状态设置                          */
 250   2              case 1:                                         
 251   2                  memcpy(rs485.TX2_buf,rs485.RX2_buf,8);
 252   2      
 253   2                  if( rs485.TX2_buf[5] & 0X01 )
 254   2                  {
 255   3                      DC_24V_out(1);
 256   3                  }else
 257   2                  {
 258   3                      DC_24V_out(0);
 259   3                  }
 260   2                  
 261   2                  rs485.TX2_send_bytelength = 8;
 262   2      
 263   2                  DR2 = 1;                                    //485可以发送
 264   2                  delay_ms(5);
 265   2                  S2CON |= S2TI;                              //开始发送
 266   2      
 267   2                  eeprom.led_info = rs485.TX2_buf[5];
 268   2                  eeprom_data_record();
 269   2      
 270   2                  break;
 271   2      
 272   2              /*  40003  220V 开关及大小设置                          */
 273   2              case 2:                                         
 274   2                  memcpy(rs485.TX2_buf,rs485.RX2_buf,8);
 275   2      
 276   2                  if( rs485.TX2_buf[5] & 0X01 )
 277   2                  {
 278   3                      INTCLKO |= 0x10;
 279   3                  }else
 280   2                  {
 281   3                      INTCLKO &= ~0x10;
 282   3                  }
 283   2                  AC_220V_out(rs485.TX2_buf[5]>>1);
 284   2      
 285   2                  rs485.TX2_send_bytelength = 8;
 286   2                  DR2 = 1;                                    //485可以发送
 287   2                  delay_ms(5);
 288   2                  S2CON |= S2TI;                              //开始发送
 289   2      
 290   2                  eeprom.ac220_info = rs485.TX2_buf[5];
 291   2                  eeprom_data_record();
 292   2      
 293   2                  break;  
 294   2                  
 295   2              /*  40004  NTC1 NTC2 alarm value 设置                   */
 296   2              case 3:                                         
 297   2                  memcpy(rs485.TX2_buf,rs485.RX2_buf,8);
 298   2      
 299   2                  temp.temp_alarm_value1 = rs485.TX2_buf[5];
 300   2                  temp.temp_alarm_value2 = rs485.TX2_buf[4];
 301   2                  
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        02/09/2025 16:48:56 PAGE 6   

 302   2                  rs485.TX2_send_bytelength = 8;
 303   2                  DR2 = 1;                                    //485可以发送
 304   2                  delay_ms(5);
 305   2                  S2CON |= S2TI;                              //开始发送
 306   2      
 307   2                  eeprom.temp_alarm_value1 = temp.temp_alarm_value1;
 308   2                  eeprom.temp_alarm_value2 = temp.temp_alarm_value2;
 309   2                  eeprom_data_record();
 310   2      
 311   2                  break;
 312   2      
 313   2              /*  40005  NTC3 alarm value 设置                        */
 314   2              case 4:                                         
 315   2                  memcpy(rs485.TX2_buf,rs485.RX2_buf,8);
 316   2      
 317   2                  temp.temp_alarm_value3 = rs485.TX2_buf[5];
 318   2                  
 319   2                  rs485.TX2_send_bytelength = 8;
 320   2                  DR2 = 1;                                    //485可以发送
 321   2                  delay_ms(5);
 322   2                  S2CON |= S2TI;                              //开始发送
 323   2      
 324   2                  eeprom.temp_alarm_value3 = temp.temp_alarm_value3;
 325   2                  eeprom_data_record();
 326   2      
 327   2                  break;
 328   2              default:
 329   2                  break;   
 330   2          }
 331   1      }
 332          
 333          /**
 334           * @brief       写多个输出寄存器  16
 335           *
 336           * @param   void
 337           *
 338           * @return  void 
 339          **/
 340          void Modbus_Fun16( void )
 341          {
 342   1          uint16_t crc;
 343   1          uint16_t i;
 344   1      
 345   1          modbus.rcv_value_addr = 7;                  //DATA1 H位置
 346   1          modbus.byte_cnt   = rs485.RX2_buf[6];
 347   1          modbus.start_addr = rs485.RX2_buf[2]<<8 | rs485.RX2_buf[3];
 348   1      
 349   1          memcpy(rs485.TX2_buf,rs485.RX2_buf,6);
 350   1      
 351   1          for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++)
 352   1          {
 353   2              modbus.byte_info_H = rs485.RX2_buf[modbus.rcv_value_addr];
 354   2              modbus.byte_info_L = rs485.RX2_buf[modbus.rcv_value_addr + 1];
 355   2              switch (i)
 356   2              {
 357   3                  /*  40001  两路PWM 开关状态及风速设置                 */
 358   3                  case 0:
 359   3                      if( modbus.byte_info_L & 0X01 )
 360   3                      {
 361   4                          PWMB_CCER2 |= 0X01;
 362   4                      }else
 363   3                      {
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        02/09/2025 16:48:56 PAGE 7   

 364   4                          PWMB_CCER2 &= 0XFE;
 365   4                      }
 366   3                      if( modbus.byte_info_L & 0X02 )
 367   3                      {
 368   4                          PWMB_CCER2 |= 0X10;
 369   4                      }else
 370   3                      {
 371   4                          PWMB_CCER2 &= 0XEF;
 372   4                      }
 373   3                      
 374   3                      PWMB_CCR7 = ((modbus.byte_info_L>>2) & 0x07)*184;
 375   3                      PWMB_CCR8 =  (modbus.byte_info_L>>5)*184;
 376   3      
 377   3                      eeprom.pwm_info = modbus.byte_info_L;
 378   3                      break;
 379   3                  
 380   3                  /*  40002  24V LED开关状态设置                          */
 381   3                  case 1:
 382   3                      if( modbus.byte_info_L & 0X01 )
 383   3                      {
 384   4                          DC_24V_out(1);
 385   4                      }else
 386   3                      {
 387   4                          DC_24V_out(0);
 388   4                      }
 389   3      
 390   3                      eeprom.led_info = modbus.byte_info_L;
 391   3                      break;
 392   3      
 393   3                  /*  40003  220V 开关及大小设置                          */
 394   3                  case 2:
 395   3                      if( modbus.byte_info_L & 0X01 )
 396   3                      {
 397   4                          INTCLKO |= 0x10;
 398   4                      }else
 399   3                      {
 400   4                          INTCLKO &= ~0x10;
 401   4                      }
 402   3                      AC_220V_out(modbus.byte_info_L>>1);
 403   3      
 404   3                      eeprom.ac220_info = modbus.byte_info_L;
 405   3                      break;
 406   3      
 407   3                  /*  40004  NTC1 NTC2 alarm value 设置                   */
 408   3                  case 3:
 409   3                      temp.temp_alarm_value1 = modbus.byte_info_L;
 410   3                      temp.temp_alarm_value2 = modbus.byte_info_H;
 411   3                      
 412   3      
 413   3                      eeprom.temp_alarm_value1 = temp.temp_alarm_value1;
 414   3                      eeprom.temp_alarm_value2 = temp.temp_alarm_value2;
 415   3                      break;
 416   3      
 417   3                  /*  40005  NTC3 alarm value 设置                        */
 418   3                  case 4:
 419   3                      temp.temp_alarm_value3 = modbus.byte_info_L;
 420   3      
 421   3                      eeprom.temp_alarm_value3 = temp.temp_alarm_value3;
 422   3                      break;
 423   3      
 424   3                  default:
 425   3                      break;
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        02/09/2025 16:48:56 PAGE 8   

 426   3              }
 427   2              modbus.rcv_value_addr += 2;         //从Value1_H →→ 从Value2_H
 428   2          }
 429   1          
 430   1          crc = MODBUS_CRC16(rs485.TX2_buf,6);
 431   1          rs485.TX2_buf[6] = crc>>8;                 //CRC H
 432   1          rs485.TX2_buf[7] = crc;                    //CRC L
 433   1      
 434   1          rs485.TX2_send_bytelength = 8;
 435   1      
 436   1          DR2 = 1;                                   //485可以发送
 437   1          delay_ms(5);
 438   1          S2CON |= S2TI;  
 439   1      
 440   1          eeprom_data_record();                      //记录更改后的值
 441   1      }
 442          
 443          /**
 444           * @brief       crc校验函数
 445           * 
 446           * @param   buf：  Address(1 byte) +Funtion(1 byte) ）+Data(n byte)   
 447           * @param   length:数据长度           
 448           * 
 449            @return  crc16:crc校验的值 2byte
 450           */
 451          uint16_t MODBUS_CRC16(uint8_t *buf, uint8_t length)
 452          {
 453   1              uint8_t i;
 454   1              uint16_t        crc16;
 455   1      
 456   1          /* 1, 预置16位CRC寄存器为0xffff（即全为1）                          */
 457   1              crc16 = 0xffff; 
 458   1      
 459   1              do
 460   1              {
 461   2              /* 2, 把8位数据与16位CRC寄存器的低位相异或，把结果放于CRC寄存器     */    
             -    
 462   2                      crc16 ^= (uint16_t)*buf;                //
 463   2                      for(i=0; i<8; i++)              
 464   2                      {
 465   3                  /* 3, 如果最低位为1，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位 再异或0xA001    */
 466   3                              if(crc16 & 1)
 467   3                  {
 468   4                      crc16 = (crc16 >> 1) ^ 0xA001;
 469   4                  }
 470   3                  /* 4, 如果最低位为0，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位                */
 471   3                  else
 472   3                  {
 473   4                      crc16 >>= 1;
 474   4                  }           
 475   3                      }
 476   2                      buf++;
 477   2              }while(--length != 0);
 478   1      
 479   1              return  (crc16);
 480   1      }
 481          
 482          /**
 483           * @brief       从机回复主机
 484           *  
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        02/09/2025 16:48:56 PAGE 9   

 485           * @param   length:数据长度           
 486           * 
 487            @return  crc16:crc校验的值 2byte
 488           */
 489          void slave_to_master(uint8_t length)
 490          {
 491   1          uint16_t crc;
 492   1      
 493   1          crc = MODBUS_CRC16(rs485.TX2_buf,length);
 494   1      
 495   1          rs485.TX2_buf[length] = crc>>8;                 //CRC H
 496   1          rs485.TX2_buf[length+1] = crc;                  //CRC L
 497   1      
 498   1          rs485.TX2_send_bytelength = length + 2;
 499   1      
 500   1          DR2 = 1;                                        //485可以发送
 501   1          delay_ms(5);
 502   1          S2CON |= S2TI;                                  //开始发送
 503   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1816    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      7       9
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
