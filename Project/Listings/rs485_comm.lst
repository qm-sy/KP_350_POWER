C51 COMPILER V9.60.7.0   RS485_COMM                                                        01/25/2025 10:52:13 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE RS485_COMM
OBJECT MODULE PLACED IN ..\Output\rs485_comm.obj
COMPILER INVOKED BY: D:\APP\Keil_v5\C51\BIN\C51.EXE ..\BSP\Src\rs485_comm.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\BSP
                    -\Inc;..\Core\Inc;..\Driver;..\Emembed\Inc;..\SYSTEM\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\rs485_comm.lst) OBJECT(..\O
                    -utput\rs485_comm.obj)

line level    source

   1          #include "rs485_comm.h"
   2          
   3          RS485 rs485;
   4          
   5          /**
   6           * @brief       串口2中断处理函数
   7           *
   8           * @param   
   9           *
  10           * @return  void
  11          **/
  12          void Uart2_ISR() interrupt 8 
  13          {   
  14   1          /* 1, 检测到硬件将S2TI置1，即发送完毕                       */
  15   1          if( S2CON & S2TI )          //
  16   1          {
  17   2              /* 2, 软件将S2TI清零，等待发送标志位重置，可继续发送    */
  18   2              S2CON &= ~S2TI;         
  19   2              rs485.TX2_busy_Flag = 0;
  20   2      
  21   2              // /* 3, 依次将TX2_buf中数据送出（写S2BUF操作即为发送）    */
  22   2              // if( rs485.TX2_send_bytelength != 0 )
  23   2              // {
  24   2              //     S2BUF = rs485.TX2_buf[rs485.TX2_send_cnt++];
  25   2              //     rs485.TX2_send_bytelength--;
  26   2              // }
  27   2          }
  28   1          
  29   1          /* 1, 检测到硬件将S2RI置1，即接收完毕                       */
  30   1          if( S2CON & S2RI )
  31   1          {
  32   2              /* 2, 软件将S2RI清零，等待接收标志位重置，可继续发送    */
  33   2              S2CON &= ~S2RI;
  34   2      
  35   2              /* 3, 判断数据包是否接收完毕                           */
  36   2              if( !rs485.RX2_rev_end_Flag )
  37   2              {
  38   3                  /* 4, 数据包大于RX_buf 则从头计数                  */
  39   3                  if( rs485.RX2_rev_cnt > 128 )
  40   3                  {
  41   4                      rs485.RX2_rev_cnt = 0;
  42   4                  }
  43   3      
  44   3                  /* 5, 依次将RX2_buf中数据接收（读S2BUF操作即为接收）*/
  45   3                  rs485.RX2_buf[rs485.RX2_rev_cnt] = S2BUF;
  46   3                  rs485.RX2_rev_cnt++;
  47   3              }
  48   2              /* 6, 重置接收完毕判断时间                              */
  49   2              rs485.RX2_rev_timeout = 50;
  50   2          }
  51   1      }
  52          
  53          /**
C51 COMPILER V9.60.7.0   RS485_COMM                                                        01/25/2025 10:52:13 PAGE 2   

  54           * @brief       是否接收完毕判断函数
  55           *
  56           * @param   
  57           *
  58           * @return  void
  59          **/
  60          void Tim0_ISR( void ) interrupt 1   //1ms
  61          {
  62   1          /* 1, 如果接收未超时                                             */
  63   1          if ( rs485.RX2_rev_timeout != 0 )  
  64   1          {
  65   2              rs485.RX2_rev_timeout--;
  66   2              /* 2, 如果接收超时                                          */
  67   2              if( rs485.RX2_rev_timeout == 0 )  
  68   2              {
  69   3                  if( rs485.RX2_rev_cnt > 0 )  
  70   3                  {   
  71   4                       /* 3, 接收完毕标志位亮起并初始化接收缓冲区         */
  72   4                      rs485.RX2_rev_end_Flag = 1;   
  73   4                      rs485.RX2_rev_cnt = 0;  
  74   4                  }
  75   3              }
  76   2          } 
  77   1      }
  78          
  79          /**
  80           * @brief       串口2发送1字节数据
  81           *
  82           * @param   
  83           *
  84           * @return  void
  85          **/
  86          void Uart2_Sendbyte( uint8_t dat )
  87          {
  88   1          while( rs485.TX2_busy_Flag );
  89   1          rs485.TX2_busy_Flag = 1;
  90   1          S2BUF = dat;
  91   1      }
  92          
  93          /**
  94           * @brief       串口2发送字符串
  95           *
  96           * @param   
  97           *
  98           * @return  void
  99          **/
 100          void Uart2_SendStr( uint8_t *sendstr )
 101          {   
 102   1          while(*sendstr)
 103   1          {
 104   2              Uart2_Sendbyte( *sendstr++ );
 105   2          }
 106   1      }
 107          
 108          /**
 109           * @brief       不定长数据接收测试函数
 110           *
 111           * @param   
 112           *
 113           * @return  void
 114          **/
 115          void uart2_test( void )
C51 COMPILER V9.60.7.0   RS485_COMM                                                        01/25/2025 10:52:13 PAGE 3   

 116          {
 117   1          if( rs485.RX2_rev_end_Flag == 1 )
 118   1          {
 119   2              if( rs485.RX2_buf[0]== 0x58 )
 120   2              {
 121   3                  if ( rs485.RX2_buf[1] == 0x85 )
 122   3                  {
 123   4                      Uart2_SendStr("receive success \r\n");
 124   4                  }else
 125   3                  {
 126   4                      Uart2_SendStr("receive error \r\n");
 127   4                  }
 128   3                  
 129   3              }
 130   2          }
 131   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    251    ----
   CONSTANT SIZE    =     36    ----
   XDATA SIZE       =    264       3
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
